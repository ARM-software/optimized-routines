#!/bin/bash

# ULP error check script.
#
# Copyright (c) 2019-2024, Arm Limited.
# SPDX-License-Identifier: MIT OR Apache-2.0 WITH LLVM-exception

#set -x
set -eu

# cd to bin directory.
cd "${0%/*}"

rmodes='n u d z'
#rmodes=n
flags="${ULPFLAGS:--q}"
emu="$@"

FAIL=0
PASS=0

t() {
    # First argument: routine name
    routine=$1; shift
    # Second and third argument: lo and hi bounds
    # Extra processing needed for bivariate routines
    IFS=',' read -ra LO <<< "$1"; shift
    IFS=',' read -ra HI <<< "$1"; shift
    ITV="${LO[0]} ${HI[0]}"
    for i in "${!LO[@]}"; do
	[[ "$i" -eq "0" ]] || ITV="$ITV x ${LO[$i]} ${HI[$i]}"
    done
    # Fourth argument: number of test points
    n=$1; shift
    # Any remaining arguments forwards directly to ulp tool
    extra_flags="$@"

    # Read ULP limits and fenv expectation from autogenerated files
    limits_file=$LIMITS
    [ $r == "n" ] || limits_file=${limits_file}_nn
    L=$(grep "^$routine " $limits_file | awk '{print $2}')
    [ -n "$L" ] || { echo ERROR: Could not determine ULP limit for $routine in $limits_file && false; }
    if grep -q "^$routine$" $DISABLE_FENV; then extra_flags="$extra_flags -f"; fi 

    # Run ULP tool
    $emu ./ulp -e $L $flags -r $r $extra_flags $routine $ITV $n && PASS=$((PASS+1)) || FAIL=$((FAIL+1)) 
}

check() {
	$emu ./ulp -f -q "$@" >/dev/null
}

# Test generic routines in all rounding modes
for r in $rmodes
do
  while read F LO HI N
  do
	[[ -z $F ]] || t $F $LO $HI $N
  done << EOF
$(cat $GEN_ITVS)
EOF
done

# Only test arch-specific routines in round-to-nearest, with sign of zero ignored (-z flag)
r=n
while read F LO HI N
do
	[[ -z $F ]] || t $F $LO $HI $N -z
done << EOF
$(cat $ARCH_ITVS)
EOF

[ 0 -eq $FAIL ] || {
	echo "FAILED $FAIL PASSED $PASS"
	exit 1
}
